## Using Java built-in synchronization: Reentrant locks and condition variables

In addition to the monitor-style synchronization associated with the `Object` class (and henceforth with any class in the language), Java offers the possibility to perform lock-based synchronization using *explicit* locks, with appropriate classes part of the standard JRE library.

### Reentrant locks

[`ReentrantLock`](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html) objects have a familiar interface, with `lock()` and `unlock()` methods.
In addition to allowing a critical section to span over multiple methods, they offer a more extensive set of operations and more control over their behavior than implicit locks associated with monitor-style synchronization.

:warning: Unlike the *implicit lock* of the monitor, that is always released when exiting a synchronized block for the object, a `ReentrantLock` is only released when calling the `unlock()` method.
If the `unlock()` call is not reached, then the lock may not be released at all, leaving to a deadlock situation.
This can happen when the `lock()` and `unlock()` calls are in different methods, and a bug in your program flow prevents from reaching the latter.
This is the main reason why monitor-style synchronization is often considered safer than using explicit locks in Java.

Even when the two calls are within the same method code, the situation can happen if the code in the critical section raises an exception: the code after the instruction that triggered the exception will not be executed.
This may include the `unlock()` statement.

It is therefore recommended to surround the section with a `try`/`finally` block (the `catch` clause is optional).
Check the following [code example](src/locks_conditions/TryFinallyExample.java) and try to run it using the *unsafe* and then the *safe* method.
The Java documentation also provides [the same recommendation](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html).

#### Question

- [ ] Find what it means for a lock to be *reentrant* and an example where this property can be convenient.

### Condition variables

A distinctive feature of explicit `ReentrantLock` locks compared to the "implicit" locks of the monitor-style synchronization is that they can be associated with *several* distinct condition variables.

You may have noticed, when working on the implementation of your shared queue in the previous part, that threads could be put to wait for two distinct reasons, or two conditions that were not met while they were running their critical section:

- (1) there was no element to consume in the queue, or
- (2) there was no space left to store a new element.

Since the monitor model allows a *single* condition variable, and therefore a single queue for waiting threads, we had to put *in the same queue* threads waiting on different conditions to be satisfied.
Since we do not know the exact condition the thread awaken by the `notify()` call expected (e.g. we could notify a thread waiting for a free slot after producing a new element in an almost-full queue, while there are threads waiting to consume that we do not notify), we had to use a `notifyAll()` call.
This results in *all waiting threads* being eventually rescheduled, competing for the lock and ultimately eating CPU cycles only for checking their condition and calling `wait()` again.

`ReentrantLock` locks allows creating multiple condition variables using their `newCondition()` method.
Each condition variable is associated with a waiting queue, with operations with the same semantics as the `wait()`, `notify()` and `notifyAll()` calls of the monitor model.
If `cond` is a condition generated by calling the `newCondition()` method of a `ReentrantLock` r, then

- `cond.await()` puts the current thread in the waiting queue for this condition and releases r;
- `cond.signal()` selects one random thread (if any) from the waiting queue of `cond` and sets its state to *Runnable*;
- `cond.signalAll()` remove all threads from the waiting queue of `cond` (if any) and set them all to the *Runnable* state.

#### Questions

- [ ] Your colleague is confused: She or he used a condition `cond` for a lock `l` and calls `cond.wait()`, while holding `l`. The code compiles, but fails with a `java.lang.IllegalMonitorStateException` runtime exception. Explain her or him what happened (and in particular why the code compiled in the first place).
- [ ] Write a new version (call its class `LockQueue`) of your shared FIFO queue (the one without the fairness guarantee of FIFO-entry/bounded waiting) using reentrant locks and two condition variables. Explain if and why you expect any performance improvement, in particular with small queues (e.g. 1 or 2 elements) under high contention.
- [ ] Write now a new version of your fair (FIFO-entry/bounded waiting) shared queue using a reentrant lock and as many condition variables as you wish. Call this class `FifoLockQueue`. Note that ideally we want a bounded number of threads to be set to Runnable when a condition can be met (i.e. we prefer to avoid calls to `signalAll()`).
- [ ] The `ReentrantLock` constructor admits a boolean named `fairness`. Using the documentation, determine if this would allow solving our FIFO-entry requirement for the shared queue, and how.

:thumbsup: We are now ready to test our different implementations of the queue on a multicore machine and analyze their performance.
